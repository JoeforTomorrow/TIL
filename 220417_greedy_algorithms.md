# 그리디 알고리즘



그리디 알고리즘이란, 단순 무식하게 탐욕적으로 문제를 푸는 알고리즘이다. 달리 말해서, `현재 상황에서 지금 당장 좋은 것만 고르는 방법`을 의미한다.

정렬, 최단 경로 등의 알고리즘들은 그 사용법을 정확히 알고 있어야만 해결할 수 있다. 이와 달리, 그리디 알고리즘으로 분류되는 다익스트라 알고리즘을 제외하면, 그리디 알고리즘은 그 사용법을 굳이 외우지 않아도 풀 수 있을 가능성이 매우 높다.

그리디 알고리즘은 그 풀이법이 매우 다양하다. 그것은 즉, 그만큼 문제를 풀기 위한 창의력, 다른 말로는 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 아이디어를 요구한다는 의미와 같다.

그만큼 그리디 알고리즘은 다양한 유형의 문제를 풀어보며 그 유형에 익숙해질 필요가 있다.

또한, 정렬 알고리즘이 사용됐을 가능성이 많으니, 이를 잘 확인해보아야 한다.

코딩 테스트 문제를 보았을 때, 문제 유형을 바로 파악하기 어렵다면 그리디 알고리즘을 생각해보아야 한다. 만약 그러고도 해답이 나오지 않는다면, 다이나믹 프로그래밍이나 그래프 알고리즘 등을 고민해 보는 것도 좋다.



## 연습



### BOJ 1817 - 짐 챙기는 숌



#### 문제

> 숌은 짐을 챙겨서 겨울캠프에서 집으로 가려고 한다. 근데 숌은 공부를 많이 하러 캠프에 온 것이기 때문에 책을 엄청나게 많이 가지고 왔다. 숌은 이 책을 방에 탑처럼 쌓아 놨다. 
>
> 숌은 책을 박스에 차곡차곡 넣어서 택배로 미리 보내려고 한다. 책은 탑처럼 차곡차곡 쌓여있기 때문에, 차례대로 박스에 넣을 수밖에 없다.
>
> 각각의 책은 무게가 있다. 그리고 박스는 최대 넣을수 있는 무게가 있다. 숌이 필요한 박스의 개수의 최솟값을 구하는 프로그램을 작성하시오.

#### 입력

\>첫째 줄에 책의 개수 N과 박스에 넣을 수 있는 최대 무게 M이 주어진다. N은 0보다 크거나 같고 50보다 작거나 같은 정수이고, M은 1,000보다 작거나 같은 자연수이다. N이 0보다 큰 경우 둘째 줄에 책의 무게가 공백을 사이에 두고 주어진다. 책의 무게는 M보다 작거나 같은 자연수이다.



#### 출력

> 첫째 줄에 필요한 박스의 개수의 최솟값을 출력한다.



```
예제 입력 1 
6 10
5 5 5 5 5 5

예제 출력 1 
3

예제 입력 2 
5 100
51 51 51 51 51

예제 출력 2 
5

예제 입력 3 
6 8
1 1 1 7 7 7

예제 출력 3 
4

예제 입력 4 
11 12
12 1 11 2 10 3 4 5 6 6 1

예제 출력 4 
6

예제 입력 5 
0 7

예제 출력 5 
0
```

b에 상자가 감당할 수 있는 최대 무게를 할당하고, c에 b의 값을 백업해뒀다. 이후 상자의 무게에서 책 무게를 빼고, 다음 번 책 무게가 남은 상자 무게보다 많이 나간다면 백업해둔 c의 값을 다시 b로 불러오도록 설정했다.

```python
a,b = map(int,input().split())
c = b
if a != 0:
  lst = list(map(int,input().split()))
  cnt = 1
  for i in range(a-1):
    if b-lst[i] >= lst[i+1]:
      b = b-lst[i]
    else:
      b = c
      cnt += 1
else:
  cnt = 0
print(cnt)
```



### BOJ 14247 - 나무 자르기



#### 문제

>영선이는 나무꾼으로 나무를 구하러 오전에 산에 오른다. 산에는 n개의 나무가 있는데, 영선이는 하루에 한 나무씩 n일 산에 오르며 나무를 잘라갈 것이다. 하지만 이 산은 영험한 기운이 있어 나무들이 밤만 되면 매우 빠른 속도로 자라는데, 그 자라는 길이는 나무마다 다르다.
>
>따라서, 어느 나무를 먼저 잘라가느냐에 따라서 총 구할 수 있는 나무의 양이 다른데,
>
>나무의 처음 길이와 하루에 자라는 양이 주어졌을 때, 영선이가 얻을 수 있는 최대 나무양을 구하시오.
>
>참고로, 자른 이후에도 나무는 0부터 다시 자라기 때문에 같은 나무를 여러 번 자를 수는 있다.



#### 입력

>첫째 줄에는 나무의 개수 n개가 있다.(1≤n≤100,000) 나무는 1번부터 n번까지 있다.
>
>다음 줄에는 첫날 올라갔을 때 나무의 길이들 Hi가 n개가 순서대로 주어진다.(1≤Hi≤100,000)
>
>그 다음 줄에는 나무들이 자라는 길이 Ai가 n개가 순서대로 주어진다.(1≤Ai≤10,000)



#### 출력

>영선이가 나무를 잘라서 구할 수 있는 최대 양을 출력하시오.

```

예제 입력 1 
5
1 3 2 4 6
2 7 3 4 1

예제 출력 1 
64

```

다음은 최초의 제출로, 인덱스 에러로 인한 오답 판정을 받았다.

```python
a=int(input())
lst1=list(map(int,input().split()))
lst2=list(map(int,input().split()))
tree = {}
for i in range(a):
  tree[lst1[i]] = lst2[i]
tree = sorted(tree.items(),key=lambda x : x[1])
cnt=0
for i in range(a-1,-1,-1):
  cnt+=tree[i][1]*i+tree[i][0]
print(cnt)
```

딕셔너리 형태로 두 리스트의 값을 받았는데, 그렇게 되면 최초 나무의 길이가 같을 경우 그 중 한 나무의 값만 들어가는 문제가 생겼다. 이후, 스스로 해당 딕셔너리를 정렬하면서 튜플 형태로 바꿨 던 것을 생각하여, 딕셔너리 형태가 아닌, 리스트 내의 튜플 형태로 바꾸어 정답 처리를 받았다.

```python
a=int(input())
lst1=list(map(int,input().split()))
lst2=list(map(int,input().split()))
lst = [True] * a
for i in range(a):
  lst[i] = (lst1[i],lst2[i])
lst = sorted(lst,key=lambda x : x[1])
cnt=0
for i in range(a-1,-1,-1):
  cnt+=lst[i][1]*i+lst[i][0]
print(cnt)
```